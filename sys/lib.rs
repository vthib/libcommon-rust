
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#[link(name="libcommon", kind="static")]
#[link(name="libcommon-iop", kind="static")]
#[link(name="libcommon-minimal", kind="static")]
extern "C" {}
    /* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
pub type byte = ::std::os::raw::c_uchar;
pub type mem_flags_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_pool_t {
    pub mem_pool: mem_flags_t,
    pub min_alignment: u32,
    pub realloc_fallback: *mut mem_pool_t,
    pub malloc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mem_pool_t,
            arg2: usize,
            arg3: usize,
            arg4: mem_flags_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mem_pool_t,
            arg2: *mut ::std::os::raw::c_void,
            arg3: usize,
            arg4: usize,
            arg5: usize,
            arg6: mem_flags_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut mem_pool_t, arg2: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout_mem_pool_t() {
    assert_eq!(
        ::std::mem::size_of::<mem_pool_t>(),
        40usize,
        concat!("Size of: ", stringify!(mem_pool_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mem_pool_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_pool_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_pool_t>())).mem_pool as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_pool_t),
            "::",
            stringify!(mem_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_pool_t>())).min_alignment as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_pool_t),
            "::",
            stringify!(min_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_pool_t>())).realloc_fallback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_pool_t),
            "::",
            stringify!(realloc_fallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_pool_t>())).malloc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_pool_t),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_pool_t>())).realloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_pool_t),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_pool_t>())).free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_pool_t),
            "::",
            stringify!(free)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opt_u64_t {
    pub v: u64,
    pub has_field: bool,
}
#[test]
fn bindgen_test_layout_opt_u64_t() {
    assert_eq!(
        ::std::mem::size_of::<opt_u64_t>(),
        16usize,
        concat!("Size of: ", stringify!(opt_u64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<opt_u64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(opt_u64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opt_u64_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opt_u64_t),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opt_u64_t>())).has_field as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opt_u64_t),
            "::",
            stringify!(has_field)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opt_bool_t {
    pub v: bool,
    pub has_field: bool,
}
#[test]
fn bindgen_test_layout_opt_bool_t() {
    assert_eq!(
        ::std::mem::size_of::<opt_bool_t>(),
        2usize,
        concat!("Size of: ", stringify!(opt_bool_t))
    );
    assert_eq!(
        ::std::mem::align_of::<opt_bool_t>(),
        1usize,
        concat!("Alignment of ", stringify!(opt_bool_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opt_bool_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opt_bool_t),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opt_bool_t>())).has_field as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(opt_bool_t),
            "::",
            stringify!(has_field)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union data_t {
    pub ptr: *mut ::std::os::raw::c_void,
    pub u32: u32,
    pub u64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_data_t() {
    assert_eq!(
        ::std::mem::size_of::<data_t>(),
        8usize,
        concat!("Size of: ", stringify!(data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(data_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<data_t>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(data_t),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<data_t>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(data_t),
            "::",
            stringify!(u32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<data_t>())).u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(data_t),
            "::",
            stringify!(u64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lstr_t {
    pub __bindgen_anon_1: lstr_t__bindgen_ty_1,
    pub len: ::std::os::raw::c_int,
    pub mem_pool: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lstr_t__bindgen_ty_1 {
    pub s: *const ::std::os::raw::c_char,
    pub v: *mut ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_lstr_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lstr_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lstr_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lstr_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lstr_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lstr_t__bindgen_ty_1>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lstr_t__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lstr_t__bindgen_ty_1>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lstr_t__bindgen_ty_1),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lstr_t__bindgen_ty_1>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lstr_t__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_lstr_t() {
    assert_eq!(
        ::std::mem::size_of::<lstr_t>(),
        16usize,
        concat!("Size of: ", stringify!(lstr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lstr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lstr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lstr_t>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lstr_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lstr_t>())).mem_pool as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lstr_t),
            "::",
            stringify!(mem_pool)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sb_t {
    pub data: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
    pub size: ::std::os::raw::c_int,
    pub skip: ::std::os::raw::c_int,
    pub mp: *mut mem_pool_t,
}
#[test]
fn bindgen_test_layout_sb_t() {
    assert_eq!(
        ::std::mem::size_of::<sb_t>(),
        32usize,
        concat!("Size of: ", stringify!(sb_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sb_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sb_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sb_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sb_t>())).len as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(sb_t), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sb_t>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sb_t>())).skip as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_t),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sb_t>())).mp as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(sb_t), "::", stringify!(mp))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pstream_t {
    pub __bindgen_anon_1: pstream_t__bindgen_ty_1,
    pub __bindgen_anon_2: pstream_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pstream_t__bindgen_ty_1 {
    pub p: *const ::std::os::raw::c_void,
    pub s: *const ::std::os::raw::c_char,
    pub b: *const byte,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pstream_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pstream_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pstream_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pstream_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pstream_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstream_t__bindgen_ty_1>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstream_t__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstream_t__bindgen_ty_1>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstream_t__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstream_t__bindgen_ty_1>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstream_t__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pstream_t__bindgen_ty_2 {
    pub p_end: *const ::std::os::raw::c_void,
    pub s_end: *const ::std::os::raw::c_char,
    pub b_end: *const byte,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pstream_t__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<pstream_t__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(pstream_t__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<pstream_t__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(pstream_t__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstream_t__bindgen_ty_2>())).p_end as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstream_t__bindgen_ty_2),
            "::",
            stringify!(p_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstream_t__bindgen_ty_2>())).s_end as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstream_t__bindgen_ty_2),
            "::",
            stringify!(s_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstream_t__bindgen_ty_2>())).b_end as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pstream_t__bindgen_ty_2),
            "::",
            stringify!(b_end)
        )
    );
}
#[test]
fn bindgen_test_layout_pstream_t() {
    assert_eq!(
        ::std::mem::size_of::<pstream_t>(),
        16usize,
        concat!("Size of: ", stringify!(pstream_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pstream_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pstream_t))
    );
}
extern "C" {
    pub fn ps_init(s: *const ::std::os::raw::c_void, len: usize) -> pstream_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn module_require(mod_: *mut module_t, required_by: *mut module_t);
}
extern "C" {
    pub fn module_release(mod_: *mut module_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ev_t {
    _unused: [u8; 0],
}
pub type el_t = *mut ev_t;
pub type el_cb_f = ::std::option::Option<unsafe extern "C" fn(arg1: el_t, arg2: data_t)>;
extern "C" {
    pub fn el_blocker_register() -> el_t;
}
extern "C" {
    pub fn el_unregister(arg1: *mut el_t) -> data_t;
}
pub const ev_priority_t_EV_PRIORITY_LOW: ev_priority_t = 0;
pub const ev_priority_t_EV_PRIORITY_NORMAL: ev_priority_t = 1;
pub const ev_priority_t_EV_PRIORITY_HIGH: ev_priority_t = 2;
pub type ev_priority_t = u32;
pub const ev_timer_flags_t_EL_TIMER_NOMISS: ev_timer_flags_t = 1;
pub const ev_timer_flags_t_EL_TIMER_LOWRES: ev_timer_flags_t = 2;
pub type ev_timer_flags_t = u32;
extern "C" {
    pub fn el_timer_register_d(
        next: i64,
        repeat: i64,
        flags: ev_timer_flags_t,
        arg1: el_cb_f,
        arg2: data_t,
    ) -> el_t;
}
extern "C" {
    pub fn el_unref(arg1: el_t) -> el_t;
}
extern "C" {
    pub fn el_loop();
}
extern "C" {
    pub fn el_loop_timeout(msecs: ::std::os::raw::c_int);
}
extern "C" {
    pub fn el_has_pending_events() -> bool;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
pub type in_port_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_un {
    pub sun_family: sa_family_t,
    pub sun_path: [::std::os::raw::c_char; 108usize],
}
#[test]
fn bindgen_test_layout_sockaddr_un() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_un>(),
        110usize,
        concat!("Size of: ", stringify!(sockaddr_un))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_un>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr_un))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_un>())).sun_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_un>())).sun_path as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_path)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sockunion_t {
    pub ss: sockaddr_storage,
    pub sin: sockaddr_in,
    pub sin6: sockaddr_in6,
    pub sunix: sockaddr_un,
    pub sa: sockaddr,
    pub family: sa_family_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_sockunion_t() {
    assert_eq!(
        ::std::mem::size_of::<sockunion_t>(),
        128usize,
        concat!("Size of: ", stringify!(sockunion_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sockunion_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sockunion_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockunion_t>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockunion_t),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockunion_t>())).sin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockunion_t),
            "::",
            stringify!(sin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockunion_t>())).sin6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockunion_t),
            "::",
            stringify!(sin6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockunion_t>())).sunix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockunion_t),
            "::",
            stringify!(sunix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockunion_t>())).sa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockunion_t),
            "::",
            stringify!(sa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockunion_t>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockunion_t),
            "::",
            stringify!(family)
        )
    );
}
extern "C" {
    pub fn addr_parse_minport(
        ps: pstream_t,
        host: *mut pstream_t,
        port: *mut in_port_t,
        minport: ::std::os::raw::c_int,
        defport: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn addr_info(
        arg1: *mut sockunion_t,
        arg2: sa_family_t,
        host: pstream_t,
        arg3: in_port_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qvector_t {
    pub tab: *mut u8,
    pub mp: *mut mem_pool_t,
    pub len: ::std::os::raw::c_int,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_qvector_t() {
    assert_eq!(
        ::std::mem::size_of::<qvector_t>(),
        24usize,
        concat!("Size of: ", stringify!(qvector_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qvector_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qvector_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qvector_t>())).tab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qvector_t),
            "::",
            stringify!(tab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qvector_t>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qvector_t),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qvector_t>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qvector_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qvector_t>())).size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qvector_t),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qv_i32_t {
    pub qv: qvector_t,
    pub __bindgen_anon_1: qv_i32_t__bindgen_ty_1,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qv_i32_t__bindgen_ty_1 {
    pub tab: *mut i32,
    pub mp: *mut mem_pool_t,
    pub len: ::std::os::raw::c_int,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_qv_i32_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qv_i32_t__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(qv_i32_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qv_i32_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(qv_i32_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qv_i32_t__bindgen_ty_1>())).tab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qv_i32_t__bindgen_ty_1),
            "::",
            stringify!(tab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qv_i32_t__bindgen_ty_1>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qv_i32_t__bindgen_ty_1),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qv_i32_t__bindgen_ty_1>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qv_i32_t__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qv_i32_t__bindgen_ty_1>())).size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qv_i32_t__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_qv_i32_t() {
    assert_eq!(
        ::std::mem::size_of::<qv_i32_t>(),
        24usize,
        concat!("Size of: ", stringify!(qv_i32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qv_i32_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qv_i32_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qv_i32_t>())).qv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qv_i32_t),
            "::",
            stringify!(qv)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qv_iovec_t {
    pub qv: qvector_t,
    pub __bindgen_anon_1: qv_iovec_t__bindgen_ty_1,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qv_iovec_t__bindgen_ty_1 {
    pub tab: *mut iovec,
    pub mp: *mut mem_pool_t,
    pub len: ::std::os::raw::c_int,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_qv_iovec_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qv_iovec_t__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(qv_iovec_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qv_iovec_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(qv_iovec_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qv_iovec_t__bindgen_ty_1>())).tab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qv_iovec_t__bindgen_ty_1),
            "::",
            stringify!(tab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qv_iovec_t__bindgen_ty_1>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qv_iovec_t__bindgen_ty_1),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qv_iovec_t__bindgen_ty_1>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qv_iovec_t__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qv_iovec_t__bindgen_ty_1>())).size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qv_iovec_t__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_qv_iovec_t() {
    assert_eq!(
        ::std::mem::size_of::<qv_iovec_t>(),
        24usize,
        concat!("Size of: ", stringify!(qv_iovec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qv_iovec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qv_iovec_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qv_iovec_t>())).qv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qv_iovec_t),
            "::",
            stringify!(qv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qhash_hdr_t {
    pub bits: *mut usize,
    pub len: u32,
    pub size: u32,
    pub mp: *mut mem_pool_t,
}
#[test]
fn bindgen_test_layout_qhash_hdr_t() {
    assert_eq!(
        ::std::mem::size_of::<qhash_hdr_t>(),
        24usize,
        concat!("Size of: ", stringify!(qhash_hdr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qhash_hdr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qhash_hdr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_hdr_t>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_hdr_t),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_hdr_t>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_hdr_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_hdr_t>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_hdr_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_hdr_t>())).mp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_hdr_t),
            "::",
            stringify!(mp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qhash_t {
    pub hdr: qhash_hdr_t,
    pub old: *mut qhash_hdr_t,
    pub keys: *mut u8,
    pub values: *mut u8,
    pub hashes: *mut u32,
    pub ghosts: u32,
    pub h_size: u8,
    pub k_size: u8,
    pub v_size: u16,
    pub minsize: u32,
}
#[test]
fn bindgen_test_layout_qhash_t() {
    assert_eq!(
        ::std::mem::size_of::<qhash_t>(),
        72usize,
        concat!("Size of: ", stringify!(qhash_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qhash_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qhash_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_t>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_t),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_t>())).old as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_t),
            "::",
            stringify!(old)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_t>())).keys as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_t),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_t>())).values as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_t),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_t>())).hashes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_t),
            "::",
            stringify!(hashes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_t>())).ghosts as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_t),
            "::",
            stringify!(ghosts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_t>())).h_size as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_t),
            "::",
            stringify!(h_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_t>())).k_size as *const _ as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_t),
            "::",
            stringify!(k_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_t>())).v_size as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_t),
            "::",
            stringify!(v_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qhash_t>())).minsize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(qhash_t),
            "::",
            stringify!(minsize)
        )
    );
}
extern "C" {
    pub fn qhash_init(qh: *mut qhash_t, k_size: u16, v_size: u16, doh: bool, mp: *mut mem_pool_t);
}
pub const iop_repeat_t_IOP_R_REQUIRED: iop_repeat_t = 0;
pub const iop_repeat_t_IOP_R_DEFVAL: iop_repeat_t = 1;
pub const iop_repeat_t_IOP_R_OPTIONAL: iop_repeat_t = 2;
pub const iop_repeat_t_IOP_R_REPEATED: iop_repeat_t = 3;
pub type iop_repeat_t = u32;
pub const iop_type_t_IOP_T_I8: iop_type_t = 0;
pub const iop_type_t_IOP_T_U8: iop_type_t = 1;
pub const iop_type_t_IOP_T_I16: iop_type_t = 2;
pub const iop_type_t_IOP_T_U16: iop_type_t = 3;
pub const iop_type_t_IOP_T_I32: iop_type_t = 4;
pub const iop_type_t_IOP_T_U32: iop_type_t = 5;
pub const iop_type_t_IOP_T_I64: iop_type_t = 6;
pub const iop_type_t_IOP_T_U64: iop_type_t = 7;
pub const iop_type_t_IOP_T_BOOL: iop_type_t = 8;
pub const iop_type_t_IOP_T_ENUM: iop_type_t = 9;
pub const iop_type_t_IOP_T_DOUBLE: iop_type_t = 10;
pub const iop_type_t_IOP_T_STRING: iop_type_t = 11;
pub const iop_type_t_IOP_T_DATA: iop_type_t = 12;
pub const iop_type_t_IOP_T_UNION: iop_type_t = 13;
pub const iop_type_t_IOP_T_STRUCT: iop_type_t = 14;
pub const iop_type_t_IOP_T_XML: iop_type_t = 15;
pub const iop_type_t_IOP_T_VOID: iop_type_t = 16;
pub type iop_type_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iop_field_t {
    pub name: lstr_t,
    pub tag: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize], u16>,
    pub size: u16,
    pub data_offs: u16,
    pub u0: iop_field_t__bindgen_ty_1,
    pub u1: iop_field_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iop_field_t__bindgen_ty_1 {
    pub defval_enum: ::std::os::raw::c_int,
    pub defval_len: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_iop_field_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<iop_field_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(iop_field_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_field_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(iop_field_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iop_field_t__bindgen_ty_1>())).defval_enum as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t__bindgen_ty_1),
            "::",
            stringify!(defval_enum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iop_field_t__bindgen_ty_1>())).defval_len as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t__bindgen_ty_1),
            "::",
            stringify!(defval_len)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iop_field_t__bindgen_ty_2 {
    pub defval_data: *const ::std::os::raw::c_void,
    pub defval_u64: u64,
    pub defval_d: f64,
    pub st_desc: *const iop_struct_t,
    pub en_desc: *const iop_enum_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_iop_field_t__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<iop_field_t__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(iop_field_t__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_field_t__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_field_t__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iop_field_t__bindgen_ty_2>())).defval_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t__bindgen_ty_2),
            "::",
            stringify!(defval_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iop_field_t__bindgen_ty_2>())).defval_u64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t__bindgen_ty_2),
            "::",
            stringify!(defval_u64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iop_field_t__bindgen_ty_2>())).defval_d as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t__bindgen_ty_2),
            "::",
            stringify!(defval_d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iop_field_t__bindgen_ty_2>())).st_desc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t__bindgen_ty_2),
            "::",
            stringify!(st_desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iop_field_t__bindgen_ty_2>())).en_desc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t__bindgen_ty_2),
            "::",
            stringify!(en_desc)
        )
    );
}
#[test]
fn bindgen_test_layout_iop_field_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_field_t>(),
        40usize,
        concat!("Size of: ", stringify!(iop_field_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_field_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_field_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_t>())).tag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_t>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_t>())).data_offs as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t),
            "::",
            stringify!(data_offs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_t>())).u0 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t),
            "::",
            stringify!(u0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_t>())).u1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_t),
            "::",
            stringify!(u1)
        )
    );
}
impl iop_field_t {
    #[inline]
    pub fn tag_len(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tag_len(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn repeat(&self) -> iop_repeat_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_repeat(&mut self, val: iop_repeat_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> iop_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: iop_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tag_len: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
        repeat: iop_repeat_t,
        type_: iop_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 6usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let tag_len: u32 = unsafe { ::std::mem::transmute(tag_len) };
            tag_len as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let repeat: u32 = unsafe { ::std::mem::transmute(repeat) };
            repeat as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iop_value_t {
    pub i: i64,
    pub i64: i64,
    pub i32: i32,
    pub u: u64,
    pub u64: u64,
    pub u32: u32,
    pub d: f64,
    pub s: lstr_t,
    pub b: bool,
    pub p: *const ::std::os::raw::c_void,
    pub v: *mut ::std::os::raw::c_void,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_iop_value_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_value_t>(),
        16usize,
        concat!("Size of: ", stringify!(iop_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_value_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_value_t>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_value_t),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_value_t>())).i64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_value_t),
            "::",
            stringify!(i64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_value_t>())).i32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_value_t),
            "::",
            stringify!(i32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_value_t>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_value_t),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_value_t>())).u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_value_t),
            "::",
            stringify!(u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_value_t>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_value_t),
            "::",
            stringify!(u32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_value_t>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_value_t),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_value_t>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_value_t),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_value_t>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_value_t),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_value_t>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_value_t),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_value_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_value_t),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iop_generic_attr_arg_t {
    pub v: iop_value_t,
}
#[test]
fn bindgen_test_layout_iop_generic_attr_arg_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_generic_attr_arg_t>(),
        16usize,
        concat!("Size of: ", stringify!(iop_generic_attr_arg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_generic_attr_arg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_generic_attr_arg_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_generic_attr_arg_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_generic_attr_arg_t),
            "::",
            stringify!(v)
        )
    );
}
pub const iop_enum_value_attr_type_t_IOP_ENUM_VALUE_ATTR_HELP: iop_enum_value_attr_type_t = 0;
pub const iop_enum_value_attr_type_t_IOP_ENUM_VALUE_GEN_ATTR_S: iop_enum_value_attr_type_t = 1;
pub const iop_enum_value_attr_type_t_IOP_ENUM_VALUE_GEN_ATTR_I: iop_enum_value_attr_type_t = 2;
pub const iop_enum_value_attr_type_t_IOP_ENUM_VALUE_GEN_ATTR_D: iop_enum_value_attr_type_t = 3;
pub const iop_enum_value_attr_type_t_IOP_ENUM_VALUE_GEN_ATTR_O: iop_enum_value_attr_type_t = 4;
pub const iop_enum_value_attr_type_t_IOP_ENUM_VALUE_ATTR_HELP_V2: iop_enum_value_attr_type_t = 5;
pub type iop_enum_value_attr_type_t = u32;
pub type iop_enum_value_attr_arg_t = iop_generic_attr_arg_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iop_enum_value_attr_t {
    pub type_: iop_enum_value_attr_type_t,
    pub args: *const iop_enum_value_attr_arg_t,
}
#[test]
fn bindgen_test_layout_iop_enum_value_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_enum_value_attr_t>(),
        16usize,
        concat!("Size of: ", stringify!(iop_enum_value_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_enum_value_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_enum_value_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_value_attr_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_value_attr_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_value_attr_t>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_value_attr_t),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iop_enum_value_attrs_t {
    pub flags: ::std::os::raw::c_uint,
    pub attrs_len: u16,
    pub version: u8,
    pub padding: u8,
    pub attrs: *const iop_enum_value_attr_t,
}
#[test]
fn bindgen_test_layout_iop_enum_value_attrs_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_enum_value_attrs_t>(),
        16usize,
        concat!("Size of: ", stringify!(iop_enum_value_attrs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_enum_value_attrs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_enum_value_attrs_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_value_attrs_t>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_value_attrs_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iop_enum_value_attrs_t>())).attrs_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_value_attrs_t),
            "::",
            stringify!(attrs_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_value_attrs_t>())).version as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_value_attrs_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_value_attrs_t>())).padding as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_value_attrs_t),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_value_attrs_t>())).attrs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_value_attrs_t),
            "::",
            stringify!(attrs)
        )
    );
}
pub const iop_enum_attr_type_t_IOP_ENUM_ATTR_HELP: iop_enum_attr_type_t = 0;
pub const iop_enum_attr_type_t_IOP_ENUM_GEN_ATTR_S: iop_enum_attr_type_t = 1;
pub const iop_enum_attr_type_t_IOP_ENUM_GEN_ATTR_I: iop_enum_attr_type_t = 2;
pub const iop_enum_attr_type_t_IOP_ENUM_GEN_ATTR_D: iop_enum_attr_type_t = 3;
pub const iop_enum_attr_type_t_IOP_ENUM_GEN_ATTR_O: iop_enum_attr_type_t = 4;
pub const iop_enum_attr_type_t_IOP_ENUM_ATTR_HELP_V2: iop_enum_attr_type_t = 5;
pub type iop_enum_attr_type_t = u32;
pub type iop_enum_attr_arg_t = iop_generic_attr_arg_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iop_enum_attr_t {
    pub type_: iop_enum_attr_type_t,
    pub args: *const iop_enum_attr_arg_t,
}
#[test]
fn bindgen_test_layout_iop_enum_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_enum_attr_t>(),
        16usize,
        concat!("Size of: ", stringify!(iop_enum_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_enum_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_enum_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_attr_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_attr_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_attr_t>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_attr_t),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iop_enum_attrs_t {
    pub flags: ::std::os::raw::c_uint,
    pub attrs_len: u16,
    pub version: u8,
    pub padding: u8,
    pub attrs: *const iop_enum_attr_t,
}
#[test]
fn bindgen_test_layout_iop_enum_attrs_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_enum_attrs_t>(),
        16usize,
        concat!("Size of: ", stringify!(iop_enum_attrs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_enum_attrs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_enum_attrs_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_attrs_t>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_attrs_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_attrs_t>())).attrs_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_attrs_t),
            "::",
            stringify!(attrs_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_attrs_t>())).version as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_attrs_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_attrs_t>())).padding as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_attrs_t),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_attrs_t>())).attrs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_attrs_t),
            "::",
            stringify!(attrs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iop_enum_alias_t {
    pub pos: ::std::os::raw::c_int,
    pub name: lstr_t,
}
#[test]
fn bindgen_test_layout_iop_enum_alias_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_enum_alias_t>(),
        24usize,
        concat!("Size of: ", stringify!(iop_enum_alias_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_enum_alias_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_enum_alias_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_alias_t>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_alias_t),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_alias_t>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_alias_t),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
pub struct iop_enum_aliases_t {
    pub len: u16,
    pub aliases: __IncompleteArrayField<iop_enum_alias_t>,
}
#[test]
fn bindgen_test_layout_iop_enum_aliases_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_enum_aliases_t>(),
        8usize,
        concat!("Size of: ", stringify!(iop_enum_aliases_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_enum_aliases_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_enum_aliases_t))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iop_enum_t {
    pub name: lstr_t,
    pub fullname: lstr_t,
    pub names: *const lstr_t,
    pub values: *const ::std::os::raw::c_int,
    pub ranges: *const ::std::os::raw::c_int,
    pub enum_len: u16,
    pub flags: u16,
    pub ranges_len: ::std::os::raw::c_int,
    pub en_attrs: *const iop_enum_attrs_t,
    pub values_attrs: *const iop_enum_value_attrs_t,
    pub aliases: *const iop_enum_aliases_t,
}
#[test]
fn bindgen_test_layout_iop_enum_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_enum_t>(),
        88usize,
        concat!("Size of: ", stringify!(iop_enum_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_enum_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_enum_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_t>())).fullname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_t),
            "::",
            stringify!(fullname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_t>())).names as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_t),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_t>())).values as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_t),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_t>())).ranges as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_t),
            "::",
            stringify!(ranges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_t>())).enum_len as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_t),
            "::",
            stringify!(enum_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_t>())).flags as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_t>())).ranges_len as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_t),
            "::",
            stringify!(ranges_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_t>())).en_attrs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_t),
            "::",
            stringify!(en_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_t>())).values_attrs as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_t),
            "::",
            stringify!(values_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_enum_t>())).aliases as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_enum_t),
            "::",
            stringify!(aliases)
        )
    );
}
pub type check_constraints_f = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type iop_field_attr_arg_t = iop_generic_attr_arg_t;
pub const iop_field_attr_type_t_IOP_FIELD_MIN_OCCURS: iop_field_attr_type_t = 0;
pub const iop_field_attr_type_t_IOP_FIELD_MAX_OCCURS: iop_field_attr_type_t = 1;
pub const iop_field_attr_type_t_IOP_FIELD_CDATA: iop_field_attr_type_t = 2;
pub const iop_field_attr_type_t_IOP_FIELD_MIN: iop_field_attr_type_t = 3;
pub const iop_field_attr_type_t_IOP_FIELD_MAX: iop_field_attr_type_t = 4;
pub const iop_field_attr_type_t_IOP_FIELD_NON_EMPTY: iop_field_attr_type_t = 5;
pub const iop_field_attr_type_t_IOP_FIELD_NON_ZERO: iop_field_attr_type_t = 6;
pub const iop_field_attr_type_t_IOP_FIELD_MIN_LENGTH: iop_field_attr_type_t = 7;
pub const iop_field_attr_type_t_IOP_FIELD_MAX_LENGTH: iop_field_attr_type_t = 8;
pub const iop_field_attr_type_t_IOP_FIELD_PATTERN: iop_field_attr_type_t = 9;
pub const iop_field_attr_type_t_IOP_FIELD_PRIVATE: iop_field_attr_type_t = 10;
pub const iop_field_attr_type_t_IOP_FIELD_ATTR_HELP: iop_field_attr_type_t = 11;
pub const iop_field_attr_type_t_IOP_FIELD_GEN_ATTR_S: iop_field_attr_type_t = 12;
pub const iop_field_attr_type_t_IOP_FIELD_GEN_ATTR_I: iop_field_attr_type_t = 13;
pub const iop_field_attr_type_t_IOP_FIELD_GEN_ATTR_D: iop_field_attr_type_t = 14;
pub const iop_field_attr_type_t_IOP_FIELD_GEN_ATTR_O: iop_field_attr_type_t = 15;
pub const iop_field_attr_type_t_IOP_FIELD_DEPRECATED: iop_field_attr_type_t = 16;
pub const iop_field_attr_type_t_IOP_FIELD_SNMP_INFO: iop_field_attr_type_t = 17;
pub const iop_field_attr_type_t_IOP_FIELD_ATTR_HELP_V2: iop_field_attr_type_t = 18;
pub type iop_field_attr_type_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iop_field_attr_t {
    pub type_: iop_field_attr_type_t,
    pub args: *const iop_field_attr_arg_t,
}
#[test]
fn bindgen_test_layout_iop_field_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_field_attr_t>(),
        16usize,
        concat!("Size of: ", stringify!(iop_field_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_field_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_field_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_attr_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_attr_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_attr_t>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_attr_t),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iop_field_attrs_t {
    pub check_constraints: check_constraints_f,
    pub flags: ::std::os::raw::c_uint,
    pub attrs_len: u16,
    pub version: u8,
    pub padding: u8,
    pub attrs: *const iop_field_attr_t,
}
#[test]
fn bindgen_test_layout_iop_field_attrs_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_field_attrs_t>(),
        24usize,
        concat!("Size of: ", stringify!(iop_field_attrs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_field_attrs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_field_attrs_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iop_field_attrs_t>())).check_constraints as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_attrs_t),
            "::",
            stringify!(check_constraints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_attrs_t>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_attrs_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_attrs_t>())).attrs_len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_attrs_t),
            "::",
            stringify!(attrs_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_attrs_t>())).version as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_attrs_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_attrs_t>())).padding as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_attrs_t),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_field_attrs_t>())).attrs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_field_attrs_t),
            "::",
            stringify!(attrs)
        )
    );
}
pub const iop_struct_attr_type_t_IOP_STRUCT_ATTR_HELP: iop_struct_attr_type_t = 0;
pub const iop_struct_attr_type_t_IOP_STRUCT_GEN_ATTR_S: iop_struct_attr_type_t = 1;
pub const iop_struct_attr_type_t_IOP_STRUCT_GEN_ATTR_I: iop_struct_attr_type_t = 2;
pub const iop_struct_attr_type_t_IOP_STRUCT_GEN_ATTR_D: iop_struct_attr_type_t = 3;
pub const iop_struct_attr_type_t_IOP_STRUCT_GEN_ATTR_O: iop_struct_attr_type_t = 4;
pub const iop_struct_attr_type_t_IOP_STRUCT_DEPRECATED: iop_struct_attr_type_t = 5;
pub const iop_struct_attr_type_t_IOP_STRUCT_ATTR_HELP_V2: iop_struct_attr_type_t = 6;
pub type iop_struct_attr_type_t = u32;
pub type iop_struct_attr_arg_t = iop_generic_attr_arg_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iop_struct_attr_t {
    pub type_: iop_struct_attr_type_t,
    pub args: *const iop_struct_attr_arg_t,
}
#[test]
fn bindgen_test_layout_iop_struct_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_struct_attr_t>(),
        16usize,
        concat!("Size of: ", stringify!(iop_struct_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_struct_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_struct_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_attr_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_attr_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_attr_t>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_attr_t),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iop_struct_attrs_t {
    pub flags: ::std::os::raw::c_uint,
    pub attrs_len: u16,
    pub version: u8,
    pub padding: u8,
    pub attrs: *const iop_struct_attr_t,
}
#[test]
fn bindgen_test_layout_iop_struct_attrs_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_struct_attrs_t>(),
        16usize,
        concat!("Size of: ", stringify!(iop_struct_attrs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_struct_attrs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_struct_attrs_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_attrs_t>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_attrs_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_attrs_t>())).attrs_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_attrs_t),
            "::",
            stringify!(attrs_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_attrs_t>())).version as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_attrs_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_attrs_t>())).padding as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_attrs_t),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_attrs_t>())).attrs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_attrs_t),
            "::",
            stringify!(attrs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iop_static_field_t {
    pub name: lstr_t,
    pub value: iop_value_t,
    pub attrs: *const iop_field_attrs_t,
    pub type_: u16,
}
#[test]
fn bindgen_test_layout_iop_static_field_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_static_field_t>(),
        48usize,
        concat!("Size of: ", stringify!(iop_static_field_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_static_field_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_static_field_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_static_field_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_static_field_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_static_field_t>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_static_field_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_static_field_t>())).attrs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_static_field_t),
            "::",
            stringify!(attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_static_field_t>())).type_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_static_field_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iop_class_attrs_t {
    pub parent: *const iop_struct_t,
    pub static_fields: *mut *const iop_static_field_t,
    pub static_fields_len: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub class_id: u16,
}
#[test]
fn bindgen_test_layout_iop_class_attrs_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_class_attrs_t>(),
        24usize,
        concat!("Size of: ", stringify!(iop_class_attrs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_class_attrs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_class_attrs_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_class_attrs_t>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_class_attrs_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_class_attrs_t>())).static_fields as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_class_attrs_t),
            "::",
            stringify!(static_fields)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iop_class_attrs_t>())).static_fields_len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_class_attrs_t),
            "::",
            stringify!(static_fields_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_class_attrs_t>())).class_id as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_class_attrs_t),
            "::",
            stringify!(class_id)
        )
    );
}
impl iop_class_attrs_t {
    #[inline]
    pub fn is_abstract(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_abstract(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_private(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_private(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn padding(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_padding(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_abstract: u8,
        is_private: u8,
        padding: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_abstract: u8 = unsafe { ::std::mem::transmute(is_abstract) };
            is_abstract as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_private: u8 = unsafe { ::std::mem::transmute(is_private) };
            is_private as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let padding: u8 = unsafe { ::std::mem::transmute(padding) };
            padding as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iop_snmp_attrs_t {
    pub parent: *const iop_struct_t,
    pub oid: u16,
    pub type_: u16,
}
#[test]
fn bindgen_test_layout_iop_snmp_attrs_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_snmp_attrs_t>(),
        16usize,
        concat!("Size of: ", stringify!(iop_snmp_attrs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_snmp_attrs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_snmp_attrs_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_snmp_attrs_t>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_snmp_attrs_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_snmp_attrs_t>())).oid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_snmp_attrs_t),
            "::",
            stringify!(oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_snmp_attrs_t>())).type_ as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_snmp_attrs_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iop_struct_t {
    pub fullname: lstr_t,
    pub fields: *const iop_field_t,
    pub ranges: *const ::std::os::raw::c_int,
    pub ranges_len: u16,
    pub fields_len: u16,
    pub size: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub st_attrs: *const iop_struct_attrs_t,
    pub fields_attrs: *const iop_field_attrs_t,
    pub __bindgen_anon_1: iop_struct_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iop_struct_t__bindgen_ty_1 {
    pub class_attrs: *const iop_class_attrs_t,
    pub snmp_attrs: *const iop_snmp_attrs_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_iop_struct_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<iop_struct_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(iop_struct_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_struct_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_struct_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iop_struct_t__bindgen_ty_1>())).class_attrs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_t__bindgen_ty_1),
            "::",
            stringify!(class_attrs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iop_struct_t__bindgen_ty_1>())).snmp_attrs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_t__bindgen_ty_1),
            "::",
            stringify!(snmp_attrs)
        )
    );
}
#[test]
fn bindgen_test_layout_iop_struct_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_struct_t>(),
        64usize,
        concat!("Size of: ", stringify!(iop_struct_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_struct_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_struct_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_t>())).fullname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_t),
            "::",
            stringify!(fullname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_t>())).fields as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_t),
            "::",
            stringify!(fields)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_t>())).ranges as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_t),
            "::",
            stringify!(ranges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_t>())).ranges_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_t),
            "::",
            stringify!(ranges_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_t>())).fields_len as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_t),
            "::",
            stringify!(fields_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_t>())).size as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_t>())).st_attrs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_t),
            "::",
            stringify!(st_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_struct_t>())).fields_attrs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_struct_t),
            "::",
            stringify!(fields_attrs)
        )
    );
}
impl iop_struct_t {
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn is_union(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_union(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: ::std::os::raw::c_uint,
        is_union: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let is_union: u32 = unsafe { ::std::mem::transmute(is_union) };
            is_union as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iop_rpc_t {
    pub name: lstr_t,
    pub args: *const iop_struct_t,
    pub result: *const iop_struct_t,
    pub exn: *const iop_struct_t,
    pub tag: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_iop_rpc_t() {
    assert_eq!(
        ::std::mem::size_of::<iop_rpc_t>(),
        48usize,
        concat!("Size of: ", stringify!(iop_rpc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<iop_rpc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(iop_rpc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_rpc_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_rpc_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_rpc_t>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_rpc_t),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_rpc_t>())).result as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_rpc_t),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_rpc_t>())).exn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_rpc_t),
            "::",
            stringify!(exn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iop_rpc_t>())).tag as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(iop_rpc_t),
            "::",
            stringify!(tag)
        )
    );
}
impl iop_rpc_t {
    #[inline]
    pub fn async_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        async_: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let async_: u32 = unsafe { ::std::mem::transmute(async_) };
            async_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct htnode_t {
    pub next: *mut htnode_t,
}
#[test]
fn bindgen_test_layout_htnode_t() {
    assert_eq!(
        ::std::mem::size_of::<htnode_t>(),
        8usize,
        concat!("Size of: ", stringify!(htnode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<htnode_t>(),
        8usize,
        concat!("Alignment of ", stringify!(htnode_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<htnode_t>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(htnode_t),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct htlist_t {
    pub head: *mut htnode_t,
    pub tail: *mut htnode_t,
}
#[test]
fn bindgen_test_layout_htlist_t() {
    assert_eq!(
        ::std::mem::size_of::<htlist_t>(),
        16usize,
        concat!("Size of: ", stringify!(htlist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<htlist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(htlist_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<htlist_t>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(htlist_t),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<htlist_t>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(htlist_t),
            "::",
            stringify!(tail)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_st {
    _unused: [u8; 0],
}
pub type SSL = ssl_st;
pub const ic__ic_priority__t_IC_PRIORITY_LOW: ic__ic_priority__t = 0;
pub const ic__ic_priority__t_IC_PRIORITY_NORMAL: ic__ic_priority__t = 1;
pub const ic__ic_priority__t_IC_PRIORITY_HIGH: ic__ic_priority__t = 2;
pub type ic__ic_priority__t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ic__tracer__t {
    pub token: u64,
    pub epoch: u64,
}
#[test]
fn bindgen_test_layout_ic__tracer__t() {
    assert_eq!(
        ::std::mem::size_of::<ic__tracer__t>(),
        16usize,
        concat!("Size of: ", stringify!(ic__tracer__t))
    );
    assert_eq!(
        ::std::mem::align_of::<ic__tracer__t>(),
        8usize,
        concat!("Alignment of ", stringify!(ic__tracer__t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__tracer__t>())).token as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__tracer__t),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__tracer__t>())).epoch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__tracer__t),
            "::",
            stringify!(epoch)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ic__simple_hdr__t {
    pub login: lstr_t,
    pub password: lstr_t,
    pub kind: lstr_t,
    pub payload: i32,
    pub dealias: opt_bool_t,
    pub host: lstr_t,
    pub group: lstr_t,
    pub source: lstr_t,
    pub workspace_id: opt_u64_t,
}
#[test]
fn bindgen_test_layout_ic__simple_hdr__t() {
    assert_eq!(
        ::std::mem::size_of::<ic__simple_hdr__t>(),
        120usize,
        concat!("Size of: ", stringify!(ic__simple_hdr__t))
    );
    assert_eq!(
        ::std::mem::align_of::<ic__simple_hdr__t>(),
        8usize,
        concat!("Alignment of ", stringify!(ic__simple_hdr__t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__simple_hdr__t>())).login as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__simple_hdr__t),
            "::",
            stringify!(login)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__simple_hdr__t>())).password as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__simple_hdr__t),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__simple_hdr__t>())).kind as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__simple_hdr__t),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__simple_hdr__t>())).payload as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__simple_hdr__t),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__simple_hdr__t>())).dealias as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__simple_hdr__t),
            "::",
            stringify!(dealias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__simple_hdr__t>())).host as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__simple_hdr__t),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__simple_hdr__t>())).group as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__simple_hdr__t),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__simple_hdr__t>())).source as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__simple_hdr__t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__simple_hdr__t>())).workspace_id as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__simple_hdr__t),
            "::",
            stringify!(workspace_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ic__route__t {
    pub __vptr: *const iop_struct_t,
}
#[test]
fn bindgen_test_layout_ic__route__t() {
    assert_eq!(
        ::std::mem::size_of::<ic__route__t>(),
        8usize,
        concat!("Size of: ", stringify!(ic__route__t))
    );
    assert_eq!(
        ::std::mem::align_of::<ic__route__t>(),
        8usize,
        concat!("Alignment of ", stringify!(ic__route__t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__route__t>())).__vptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__route__t),
            "::",
            stringify!(__vptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ic__routing_hdr__t {
    pub route: *mut ic__route__t,
    pub ttl: i32,
    pub priority: ic__ic_priority__t,
    pub tracer: *mut ic__tracer__t,
    pub original_hdr: *mut ic__hdr__t,
}
#[test]
fn bindgen_test_layout_ic__routing_hdr__t() {
    assert_eq!(
        ::std::mem::size_of::<ic__routing_hdr__t>(),
        32usize,
        concat!("Size of: ", stringify!(ic__routing_hdr__t))
    );
    assert_eq!(
        ::std::mem::align_of::<ic__routing_hdr__t>(),
        8usize,
        concat!("Alignment of ", stringify!(ic__routing_hdr__t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__routing_hdr__t>())).route as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__routing_hdr__t),
            "::",
            stringify!(route)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__routing_hdr__t>())).ttl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__routing_hdr__t),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__routing_hdr__t>())).priority as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__routing_hdr__t),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__routing_hdr__t>())).tracer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__routing_hdr__t),
            "::",
            stringify!(tracer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__routing_hdr__t>())).original_hdr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__routing_hdr__t),
            "::",
            stringify!(original_hdr)
        )
    );
}
pub const ic__hdr__tag_t_ic__hdr__simple__ft: ic__hdr__tag_t = 1;
pub const ic__hdr__tag_t_ic__hdr__routing__ft: ic__hdr__tag_t = 2;
pub type ic__hdr__tag_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ic__hdr__t {
    pub iop_tag: ic__hdr__tag_t,
    pub __bindgen_anon_1: ic__hdr__t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ic__hdr__t__bindgen_ty_1 {
    pub simple: ic__simple_hdr__t,
    pub routing: ic__routing_hdr__t,
    _bindgen_union_align: [u64; 15usize],
}
#[test]
fn bindgen_test_layout_ic__hdr__t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ic__hdr__t__bindgen_ty_1>(),
        120usize,
        concat!("Size of: ", stringify!(ic__hdr__t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ic__hdr__t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ic__hdr__t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__hdr__t__bindgen_ty_1>())).simple as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__hdr__t__bindgen_ty_1),
            "::",
            stringify!(simple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic__hdr__t__bindgen_ty_1>())).routing as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__hdr__t__bindgen_ty_1),
            "::",
            stringify!(routing)
        )
    );
}
#[test]
fn bindgen_test_layout_ic__hdr__t() {
    assert_eq!(
        ::std::mem::size_of::<ic__hdr__t>(),
        128usize,
        concat!("Size of: ", stringify!(ic__hdr__t))
    );
    assert_eq!(
        ::std::mem::align_of::<ic__hdr__t>(),
        8usize,
        concat!("Alignment of ", stringify!(ic__hdr__t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic__hdr__t>())).iop_tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic__hdr__t),
            "::",
            stringify!(iop_tag)
        )
    );
}
pub const ic_status_t_IC_MSG_OK: ic_status_t = 0;
pub const ic_status_t_IC_MSG_EXN: ic_status_t = 1;
pub const ic_status_t_IC_MSG_RETRY: ic_status_t = 2;
pub const ic_status_t_IC_MSG_ABORT: ic_status_t = 3;
pub const ic_status_t_IC_MSG_INVALID: ic_status_t = 4;
pub const ic_status_t_IC_MSG_UNIMPLEMENTED: ic_status_t = 5;
pub const ic_status_t_IC_MSG_SERVER_ERROR: ic_status_t = 6;
pub const ic_status_t_IC_MSG_PROXY_ERROR: ic_status_t = 7;
pub const ic_status_t_IC_MSG_TIMEDOUT: ic_status_t = 8;
pub const ic_status_t_IC_MSG_CANCELED: ic_status_t = 9;
pub type ic_status_t = u32;
pub const ic_event_t_IC_EVT_CONNECTED: ic_event_t = 0;
pub const ic_event_t_IC_EVT_DISCONNECTED: ic_event_t = 1;
pub const ic_event_t_IC_EVT_ACT: ic_event_t = 2;
pub const ic_event_t_IC_EVT_NOACT: ic_event_t = 3;
pub type ic_event_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ic_creds_t {
    pub uid: uid_t,
    pub gid: gid_t,
    pub pid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ic_creds_t() {
    assert_eq!(
        ::std::mem::size_of::<ic_creds_t>(),
        12usize,
        concat!("Size of: ", stringify!(ic_creds_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ic_creds_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ic_creds_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_creds_t>())).uid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_creds_t),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_creds_t>())).gid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_creds_t),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_creds_t>())).pid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_creds_t),
            "::",
            stringify!(pid)
        )
    );
}
pub type ic_hook_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ichannel_t, evt: ic_event_t)>;
pub type ic_pre_hook_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ichannel_t,
        arg2: u64,
        arg3: *mut ic__hdr__t,
        arg4: data_t,
        hdr_modified: *mut bool,
    ),
>;
pub type ic_post_hook_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ichannel_t,
        arg2: ic_status_t,
        arg3: *mut ic_hook_ctx_t,
        arg4: data_t,
        arg5: *const iop_struct_t,
        arg6: *const ::std::os::raw::c_void,
    ),
>;
pub type ic_creds_f = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ichannel_t, creds: *const ic_creds_t) -> ::std::os::raw::c_int,
>;
pub type ic_msg_cb_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ichannel_t,
        arg2: *mut ic_msg_t,
        arg3: ic_status_t,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut ::std::os::raw::c_void,
    ),
>;
pub type ic_msg_cb2_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ichannel_t,
        arg2: *mut ic_msg_t,
        arg3: ic_status_t,
        res: *const ::std::os::raw::c_uchar,
        rlen: u32,
        exn: *const ::std::os::raw::c_uchar,
        elen: u32,
    ),
>;
#[repr(C)]
pub struct ic_msg_t {
    pub msg_link: htnode_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub cmd: i32,
    pub slot: u32,
    pub timeout: u32,
    pub ic: *mut ichannel_t,
    pub timeout_timer: el_t,
    pub dlen: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_void,
    pub raw_res: pstream_t,
    pub hdr: *const ic__hdr__t,
    pub rpc: *const iop_rpc_t,
    pub cb: ic_msg_cb_f,
    pub cb2: ic_msg_cb2_f,
    pub priv_: __IncompleteArrayField<byte>,
}
#[test]
fn bindgen_test_layout_ic_msg_t() {
    assert_eq!(
        ::std::mem::size_of::<ic_msg_t>(),
        104usize,
        concat!("Size of: ", stringify!(ic_msg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ic_msg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ic_msg_t))
    );
}
impl ic_msg_t {
    #[inline]
    pub fn fd(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_fd(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn async_(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_async(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn raw(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_raw(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_pack(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_pack(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_dup(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_dup(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trace(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_trace(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn canceled(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_canceled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn priority(&self) -> ev_priority_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: ev_priority_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fd: ::std::os::raw::c_int,
        async_: bool,
        raw: bool,
        force_pack: bool,
        force_dup: bool,
        trace: bool,
        canceled: bool,
        priority: ev_priority_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let fd: u32 = unsafe { ::std::mem::transmute(fd) };
            fd as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let async_: u8 = unsafe { ::std::mem::transmute(async_) };
            async_ as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let raw: u8 = unsafe { ::std::mem::transmute(raw) };
            raw as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let force_pack: u8 = unsafe { ::std::mem::transmute(force_pack) };
            force_pack as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let force_dup: u8 = unsafe { ::std::mem::transmute(force_dup) };
            force_dup as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let trace: u8 = unsafe { ::std::mem::transmute(trace) };
            trace as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let canceled: u8 = unsafe { ::std::mem::transmute(canceled) };
            canceled as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let priority: u32 = unsafe { ::std::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ic_msg_new(len: ::std::os::raw::c_int) -> *mut ic_msg_t;
}
extern "C" {
    pub fn ic_msg_delete(arg1: *mut *mut ic_msg_t);
}
extern "C" {
    pub fn ic_msg_new_for_reply(
        ic: *mut *mut ichannel_t,
        slot: u64,
        cmd: ::std::os::raw::c_int,
    ) -> *mut ic_msg_t;
}
extern "C" {
    pub fn ic_queue_for_reply(ic: *mut ichannel_t, msg: *mut ic_msg_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qm_ic_msg_t {
    pub qh: qhash_t,
    pub __bindgen_anon_1: qm_ic_msg_t__bindgen_ty_1,
    _bindgen_union_align: [u64; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qm_ic_msg_t__bindgen_ty_1 {
    pub hdr: qhash_hdr_t,
    pub old: *mut qhash_hdr_t,
    pub keys: *mut u32,
    pub values: *mut *mut ic_msg_t,
    pub hashes: *mut u32,
    pub ghosts: u32,
    pub h_size: u8,
    pub k_size: u8,
    pub v_size: u16,
    pub minsize: u32,
}
#[test]
fn bindgen_test_layout_qm_ic_msg_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qm_ic_msg_t__bindgen_ty_1>(),
        72usize,
        concat!("Size of: ", stringify!(qm_ic_msg_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qm_ic_msg_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(qm_ic_msg_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qm_ic_msg_t__bindgen_ty_1>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_msg_t__bindgen_ty_1),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qm_ic_msg_t__bindgen_ty_1>())).old as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_msg_t__bindgen_ty_1),
            "::",
            stringify!(old)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qm_ic_msg_t__bindgen_ty_1>())).keys as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_msg_t__bindgen_ty_1),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_msg_t__bindgen_ty_1>())).values as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_msg_t__bindgen_ty_1),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_msg_t__bindgen_ty_1>())).hashes as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_msg_t__bindgen_ty_1),
            "::",
            stringify!(hashes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_msg_t__bindgen_ty_1>())).ghosts as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_msg_t__bindgen_ty_1),
            "::",
            stringify!(ghosts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_msg_t__bindgen_ty_1>())).h_size as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_msg_t__bindgen_ty_1),
            "::",
            stringify!(h_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_msg_t__bindgen_ty_1>())).k_size as *const _ as usize
        },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_msg_t__bindgen_ty_1),
            "::",
            stringify!(k_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_msg_t__bindgen_ty_1>())).v_size as *const _ as usize
        },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_msg_t__bindgen_ty_1),
            "::",
            stringify!(v_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_msg_t__bindgen_ty_1>())).minsize as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_msg_t__bindgen_ty_1),
            "::",
            stringify!(minsize)
        )
    );
}
#[test]
fn bindgen_test_layout_qm_ic_msg_t() {
    assert_eq!(
        ::std::mem::size_of::<qm_ic_msg_t>(),
        72usize,
        concat!("Size of: ", stringify!(qm_ic_msg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qm_ic_msg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qm_ic_msg_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qm_ic_msg_t>())).qh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_msg_t),
            "::",
            stringify!(qh)
        )
    );
}
#[repr(C)]
pub struct ic_hook_ctx_t {
    pub slot: u64,
    pub post_hook: ic_post_hook_f,
    pub rpc: *const iop_rpc_t,
    pub post_hook_args: data_t,
    pub data: __IncompleteArrayField<byte>,
}
#[test]
fn bindgen_test_layout_ic_hook_ctx_t() {
    assert_eq!(
        ::std::mem::size_of::<ic_hook_ctx_t>(),
        32usize,
        concat!("Size of: ", stringify!(ic_hook_ctx_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ic_hook_ctx_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ic_hook_ctx_t))
    );
}
pub const ic_cb_entry_type_t_IC_CB_NORMAL: ic_cb_entry_type_t = 0;
pub const ic_cb_entry_type_t_IC_CB_NORMAL_BLK: ic_cb_entry_type_t = 1;
pub const ic_cb_entry_type_t_IC_CB_NORMAL_RAW: ic_cb_entry_type_t = 2;
pub const ic_cb_entry_type_t_IC_CB_PROXY_P: ic_cb_entry_type_t = 3;
pub const ic_cb_entry_type_t_IC_CB_PROXY_PP: ic_cb_entry_type_t = 4;
pub const ic_cb_entry_type_t_IC_CB_DYNAMIC_PROXY: ic_cb_entry_type_t = 5;
pub const ic_cb_entry_type_t_IC_CB_WS_SHARED: ic_cb_entry_type_t = 6;
pub type ic_cb_entry_type_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ic_dynproxy_t {
    pub ic: *mut ichannel_t,
    pub hdr: *mut ic__hdr__t,
}
#[test]
fn bindgen_test_layout_ic_dynproxy_t() {
    assert_eq!(
        ::std::mem::size_of::<ic_dynproxy_t>(),
        16usize,
        concat!("Size of: ", stringify!(ic_dynproxy_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ic_dynproxy_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ic_dynproxy_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_dynproxy_t>())).ic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_dynproxy_t),
            "::",
            stringify!(ic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_dynproxy_t>())).hdr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_dynproxy_t),
            "::",
            stringify!(hdr)
        )
    );
}
pub type ic_dynproxy_f = ::std::option::Option<
    unsafe extern "C" fn(hdr: *mut ic__hdr__t, priv_: *mut ::std::os::raw::c_void) -> ic_dynproxy_t,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ic_cb_entry_t {
    pub cb_type: ic_cb_entry_type_t,
    pub __bindgen_anon_1: ic_cb_entry_t__bindgen_ty_1,
    pub pre_hook: ic_pre_hook_f,
    pub post_hook: ic_post_hook_f,
    pub pre_hook_args: data_t,
    pub post_hook_args: data_t,
    pub u: ic_cb_entry_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ic_cb_entry_t__bindgen_ty_1 {
    pub rpc: *const iop_rpc_t,
    pub rpc_raw: ic_cb_entry_t__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ic_cb_entry_t__bindgen_ty_1__bindgen_ty_1 {
    pub async_: bool,
}
#[test]
fn bindgen_test_layout_ic_cb_entry_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ic_cb_entry_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(ic_cb_entry_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ic_cb_entry_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(ic_cb_entry_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_1__bindgen_ty_1>())).async_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(async_)
        )
    );
}
#[test]
fn bindgen_test_layout_ic_cb_entry_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ic_cb_entry_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ic_cb_entry_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ic_cb_entry_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ic_cb_entry_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_1>())).rpc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_1),
            "::",
            stringify!(rpc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_1>())).rpc_raw as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_1),
            "::",
            stringify!(rpc_raw)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ic_cb_entry_t__bindgen_ty_2 {
    pub cb: ic_cb_entry_t__bindgen_ty_2__bindgen_ty_1,
    pub cbr: ic_cb_entry_t__bindgen_ty_2__bindgen_ty_2,
    pub proxy_p: ic_cb_entry_t__bindgen_ty_2__bindgen_ty_3,
    pub proxy_pp: ic_cb_entry_t__bindgen_ty_2__bindgen_ty_4,
    pub dynproxy: ic_cb_entry_t__bindgen_ty_2__bindgen_ty_5,
    pub iws_cb: ic_cb_entry_t__bindgen_ty_2__bindgen_ty_6,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ic_cb_entry_t__bindgen_ty_2__bindgen_ty_1 {
    pub cb: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ichannel_t,
            arg2: u64,
            arg3: *mut ::std::os::raw::c_void,
            arg4: *const ic__hdr__t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ic_cb_entry_t__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_1>())).cb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(cb)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ic_cb_entry_t__bindgen_ty_2__bindgen_ty_2 {
    pub cb: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ichannel_t,
            arg2: u64,
            arg3: i32,
            arg4: lstr_t,
            arg5: *const ic__hdr__t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ic_cb_entry_t__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_2>())).cb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(cb)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ic_cb_entry_t__bindgen_ty_2__bindgen_ty_3 {
    pub ic_p: *mut ichannel_t,
    pub hdr_p: *mut ic__hdr__t,
}
#[test]
fn bindgen_test_layout_ic_cb_entry_t__bindgen_ty_2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_3>())).ic_p as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(ic_p)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_3>())).hdr_p as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(hdr_p)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ic_cb_entry_t__bindgen_ty_2__bindgen_ty_4 {
    pub ic_pp: *mut *mut ichannel_t,
    pub hdr_pp: *mut *mut ic__hdr__t,
}
#[test]
fn bindgen_test_layout_ic_cb_entry_t__bindgen_ty_2__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_4>())).ic_pp as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_4),
            "::",
            stringify!(ic_pp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_4>())).hdr_pp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_4),
            "::",
            stringify!(hdr_pp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ic_cb_entry_t__bindgen_ty_2__bindgen_ty_5 {
    pub get_ic: ic_dynproxy_f,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ic_cb_entry_t__bindgen_ty_2__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_5>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_5>())).get_ic as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_5),
            "::",
            stringify!(get_ic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_5>())).priv_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_5),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ic_cb_entry_t__bindgen_ty_2__bindgen_ty_6 {
    pub cb: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: u64,
            arg3: *mut ::std::os::raw::c_void,
            arg4: *const ic__hdr__t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ic_cb_entry_t__bindgen_ty_2__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_6>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2__bindgen_ty_6>())).cb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2__bindgen_ty_6),
            "::",
            stringify!(cb)
        )
    );
}
#[test]
fn bindgen_test_layout_ic_cb_entry_t__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ic_cb_entry_t__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(ic_cb_entry_t__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<ic_cb_entry_t__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(ic_cb_entry_t__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2>())).cb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2>())).cbr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2),
            "::",
            stringify!(cbr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2>())).proxy_p as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2),
            "::",
            stringify!(proxy_p)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2>())).proxy_pp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2),
            "::",
            stringify!(proxy_pp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2>())).dynproxy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2),
            "::",
            stringify!(dynproxy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ic_cb_entry_t__bindgen_ty_2>())).iws_cb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t__bindgen_ty_2),
            "::",
            stringify!(iws_cb)
        )
    );
}
#[test]
fn bindgen_test_layout_ic_cb_entry_t() {
    assert_eq!(
        ::std::mem::size_of::<ic_cb_entry_t>(),
        64usize,
        concat!("Size of: ", stringify!(ic_cb_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ic_cb_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ic_cb_entry_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_cb_entry_t>())).cb_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t),
            "::",
            stringify!(cb_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_cb_entry_t>())).pre_hook as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t),
            "::",
            stringify!(pre_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_cb_entry_t>())).post_hook as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t),
            "::",
            stringify!(post_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_cb_entry_t>())).pre_hook_args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t),
            "::",
            stringify!(pre_hook_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_cb_entry_t>())).post_hook_args as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t),
            "::",
            stringify!(post_hook_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ic_cb_entry_t>())).u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ic_cb_entry_t),
            "::",
            stringify!(u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qm_ic_cbs_t {
    pub qh: qhash_t,
    pub __bindgen_anon_1: qm_ic_cbs_t__bindgen_ty_1,
    _bindgen_union_align: [u64; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qm_ic_cbs_t__bindgen_ty_1 {
    pub hdr: qhash_hdr_t,
    pub old: *mut qhash_hdr_t,
    pub keys: *mut u32,
    pub values: *mut ic_cb_entry_t,
    pub hashes: *mut u32,
    pub ghosts: u32,
    pub h_size: u8,
    pub k_size: u8,
    pub v_size: u16,
    pub minsize: u32,
}
#[test]
fn bindgen_test_layout_qm_ic_cbs_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qm_ic_cbs_t__bindgen_ty_1>(),
        72usize,
        concat!("Size of: ", stringify!(qm_ic_cbs_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qm_ic_cbs_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(qm_ic_cbs_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qm_ic_cbs_t__bindgen_ty_1>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_cbs_t__bindgen_ty_1),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qm_ic_cbs_t__bindgen_ty_1>())).old as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_cbs_t__bindgen_ty_1),
            "::",
            stringify!(old)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qm_ic_cbs_t__bindgen_ty_1>())).keys as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_cbs_t__bindgen_ty_1),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_cbs_t__bindgen_ty_1>())).values as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_cbs_t__bindgen_ty_1),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_cbs_t__bindgen_ty_1>())).hashes as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_cbs_t__bindgen_ty_1),
            "::",
            stringify!(hashes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_cbs_t__bindgen_ty_1>())).ghosts as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_cbs_t__bindgen_ty_1),
            "::",
            stringify!(ghosts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_cbs_t__bindgen_ty_1>())).h_size as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_cbs_t__bindgen_ty_1),
            "::",
            stringify!(h_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_cbs_t__bindgen_ty_1>())).k_size as *const _ as usize
        },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_cbs_t__bindgen_ty_1),
            "::",
            stringify!(k_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_cbs_t__bindgen_ty_1>())).v_size as *const _ as usize
        },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_cbs_t__bindgen_ty_1),
            "::",
            stringify!(v_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qm_ic_cbs_t__bindgen_ty_1>())).minsize as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_cbs_t__bindgen_ty_1),
            "::",
            stringify!(minsize)
        )
    );
}
#[test]
fn bindgen_test_layout_qm_ic_cbs_t() {
    assert_eq!(
        ::std::mem::size_of::<qm_ic_cbs_t>(),
        72usize,
        concat!("Size of: ", stringify!(qm_ic_cbs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qm_ic_cbs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qm_ic_cbs_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qm_ic_cbs_t>())).qh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qm_ic_cbs_t),
            "::",
            stringify!(qh)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ichannel_t {
    pub id: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub nextslot: ::std::os::raw::c_uint,
    pub elh: el_t,
    pub timer: el_t,
    pub owner: *mut *mut ichannel_t,
    pub priv_: *mut ::std::os::raw::c_void,
    pub peer: *mut ::std::os::raw::c_void,
    pub desc: *const iop_rpc_t,
    pub cmd: ::std::os::raw::c_int,
    pub priority: ev_priority_t,
    pub wa_soft_timer: el_t,
    pub wa_soft: ::std::os::raw::c_int,
    pub wa_hard: ::std::os::raw::c_int,
    pub peer_version: u16,
    pub protocol: ::std::os::raw::c_int,
    pub retry_delay: ::std::os::raw::c_int,
    pub su: sockunion_t,
    pub impl_: *const qm_ic_cbs_t,
    pub on_event: ic_hook_f,
    pub on_creds: ic_creds_f,
    pub on_wipe: ::std::option::Option<unsafe extern "C" fn(ic: *mut ichannel_t)>,
    pub queries: qm_ic_msg_t,
    pub iov_list: htlist_t,
    pub msg_list: htlist_t,
    pub last_normal_prio_msg: *mut htnode_t,
    pub current_fd: ::std::os::raw::c_int,
    pub pending: ::std::os::raw::c_int,
    pub queue_len: ::std::os::raw::c_int,
    pub ssl: *mut SSL,
    pub fds: qv_i32_t,
    pub iov: qv_iovec_t,
    pub iov_total_len: ::std::os::raw::c_int,
    pub rbuf: sb_t,
    pub peer_address: lstr_t,
    pub pending_max: ::std::os::raw::c_int,
    pub priv_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ichannel_t() {
    assert_eq!(
        ::std::mem::size_of::<ichannel_t>(),
        520usize,
        concat!("Size of: ", stringify!(ichannel_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ichannel_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ichannel_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).nextslot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(nextslot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).elh as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(elh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).timer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).owner as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).priv_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).peer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(peer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).desc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).cmd as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).priority as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).wa_soft_timer as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(wa_soft_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).wa_soft as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(wa_soft)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).wa_hard as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(wa_hard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).peer_version as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(peer_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).protocol as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).retry_delay as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(retry_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).su as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(su)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).impl_ as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).on_event as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(on_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).on_creds as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(on_creds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).on_wipe as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(on_wipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).queries as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(queries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).iov_list as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(iov_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).msg_list as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(msg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).last_normal_prio_msg as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(last_normal_prio_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).current_fd as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(current_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).pending as *const _ as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).queue_len as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(queue_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).ssl as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(ssl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).fds as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).iov as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).iov_total_len as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(iov_total_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).rbuf as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(rbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).peer_address as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(peer_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).pending_max as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(pending_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ichannel_t>())).priv_data as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(ichannel_t),
            "::",
            stringify!(priv_data)
        )
    );
}
impl ichannel_t {
    #[inline]
    pub fn is_closing(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_closing(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_spawned(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_spawned(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_autodel(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_autodel(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_seqpacket(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_seqpacket(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_unix(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_unix(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_reconn(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_reconn(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_el_unref(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_do_el_unref(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_wiped(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_wiped(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cancel_guard(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cancel_guard(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn queuable(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_queuable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_local(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_local(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_trusted(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_trusted(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_public(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_public(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fd_overflow(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fd_overflow(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hdr_checked(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hdr_checked(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tls_required(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tls_required(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_connected(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_connected(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_closing: bool,
        is_spawned: bool,
        no_autodel: bool,
        is_seqpacket: bool,
        is_unix: bool,
        auto_reconn: bool,
        do_el_unref: bool,
        is_wiped: bool,
        cancel_guard: bool,
        queuable: bool,
        is_local: bool,
        is_trusted: bool,
        is_public: bool,
        fd_overflow: bool,
        hdr_checked: bool,
        tls_required: bool,
        is_connected: bool,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_closing: u8 = unsafe { ::std::mem::transmute(is_closing) };
            is_closing as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_spawned: u8 = unsafe { ::std::mem::transmute(is_spawned) };
            is_spawned as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_autodel: u8 = unsafe { ::std::mem::transmute(no_autodel) };
            no_autodel as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_seqpacket: u8 = unsafe { ::std::mem::transmute(is_seqpacket) };
            is_seqpacket as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_unix: u8 = unsafe { ::std::mem::transmute(is_unix) };
            is_unix as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let auto_reconn: u8 = unsafe { ::std::mem::transmute(auto_reconn) };
            auto_reconn as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let do_el_unref: u8 = unsafe { ::std::mem::transmute(do_el_unref) };
            do_el_unref as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_wiped: u8 = unsafe { ::std::mem::transmute(is_wiped) };
            is_wiped as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cancel_guard: u8 = unsafe { ::std::mem::transmute(cancel_guard) };
            cancel_guard as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let queuable: u8 = unsafe { ::std::mem::transmute(queuable) };
            queuable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let is_local: u8 = unsafe { ::std::mem::transmute(is_local) };
            is_local as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let is_trusted: u8 = unsafe { ::std::mem::transmute(is_trusted) };
            is_trusted as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let is_public: u8 = unsafe { ::std::mem::transmute(is_public) };
            is_public as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fd_overflow: u8 = unsafe { ::std::mem::transmute(fd_overflow) };
            fd_overflow as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let hdr_checked: u8 = unsafe { ::std::mem::transmute(hdr_checked) };
            hdr_checked as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tls_required: u8 = unsafe { ::std::mem::transmute(tls_required) };
            tls_required as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_connected: u8 = unsafe { ::std::mem::transmute(is_connected) };
            is_connected as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ic_get_module() -> *mut module_t;
}
extern "C" {
    pub fn ic_init(arg1: *mut ichannel_t) -> *mut ichannel_t;
}
extern "C" {
    pub fn ic_wipe(arg1: *mut ichannel_t);
}
extern "C" {
    pub fn ic_connect(ic: *mut ichannel_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ic_connect_blocking(
        ic: *mut ichannel_t,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ic_disconnect(ic: *mut ichannel_t);
}
extern "C" {
    pub fn ic_spawn(ic: *mut ichannel_t, fd: ::std::os::raw::c_int, fn_: ic_creds_f);
}
extern "C" {
    pub fn ic_listento(
        su: *const sockunion_t,
        type_: ::std::os::raw::c_int,
        proto: ::std::os::raw::c_int,
        priv_: *mut ::std::os::raw::c_void,
        on_accept: ::std::option::Option<
            unsafe extern "C" fn(
                ev: el_t,
                fd: ::std::os::raw::c_int,
                priv_: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> el_t;
}
extern "C" {
    pub fn _ic_register(h: *mut qm_ic_cbs_t, cmd: i32, e: *mut ic_cb_entry_t);
}
extern "C" {
    pub fn __ic_query(arg1: *mut ichannel_t, arg2: *mut ic_msg_t);
}
